//namedTypes.TSExpressionWithTypeArguments | namedTypes.TSTypeReference | namedTypes.TSAnyKeyword | namedTypes.TSBigIntKeyword | namedTypes.TSBooleanKeyword | namedTypes.TSNeverKeyword | namedTypes.TSNullKeyword | namedTypes.TSNumberKeyword | namedTypes.TSObjectKeyword | namedTypes.TSStringKeyword | namedTypes.TSSymbolKeyword | namedTypes.TSUndefinedKeyword | namedTypes.TSUnknownKeyword | namedTypes.TSVoidKeyword | namedTypes.TSThisType | namedTypes.TSArrayType | namedTypes.TSLiteralType | namedTypes.TSUnionType | namedTypes.TSIntersectionType | namedTypes.TSConditionalType | namedTypes.TSInferType | namedTypes.TSParenthesizedType | namedTypes.TSFunctionType | namedTypes.TSConstructorType | namedTypes.TSMappedType | namedTypes.TSTupleType | namedTypes.TSRestType | namedTypes.TSOptionalType | namedTypes.TSIndexedAccessType | namedTypes.TSTypeOperator | namedTypes.TSTypeQuery | namedTypes.TSImportType | namedTypes.TSTypeLiteral;
//namedTypes.TypeAnnotation | namedTypes.TSTypeAnnotation | namedTypes.TSTypePredicate;

function typeDescription(aType: K.TypeAnnotationKind | K.TSTypeAnnotationKind | K.TSTypeKind ): AType  {
// type TSTypeKind = namedTypes.TSExpressionWithTypeArguments | namedTypes.TSTypeReference | namedTypes.TSAnyKeyword | namedTypes.TSBigIntKeyword | namedTypes.TSBooleanKeyword | namedTypes.TSNeverKeyword | namedTypes.TSNullKeyword | namedTypes.TSNumberKeyword | namedTypes.TSObjectKeyword | namedTypes.TSStringKeyword | namedTypes.TSSymbolKeyword | namedTypes.TSUndefinedKeyword | namedTypes.TSUnknownKeyword | namedTypes.TSVoidKeyword | namedTypes.TSThisType | namedTypes.TSArrayType | namedTypes.TSLiteralType | namedTypes.TSUnionType | namedTypes.TSIntersectionType | namedTypes.TSConditionalType | namedTypes.TSInferType | namedTypes.TSParenthesizedType | namedTypes.TSFunctionType | namedTypes.TSConstructorType | namedTypes.TSMappedType | namedTypes.TSTupleType | namedTypes.TSRestType | namedTypes.TSOptionalType | namedTypes.TSIndexedAccessType | namedTypes.TSTypeOperator | namedTypes.TSTypeQuery | namedTypes.TSImportType | namedTypes.TSTypeLiteral;
    if(aType.type === "TypeAnnotation") {
        throw new Error('hi');
    } else if(aType.type === "TSTypePredicate") {
        return 'predicaste';
    } else if (aType.type === "TSTypeAnnotation") {
        const ann = aType.typeAnnotation; // K.TSTypeKind | K.TSTypeAnnotationKind;
        return 'annotation ' + typeDescription(ann);
    } else if(aType.type === 'TSTypeReference') {
        const typeName = aType.typeName;
        if (typeName.type === 'Identifier') {
            return 'reference ' + typeName.name;
        } else {
            throw new Error(typeName.type);
        }/*
    } else  if (aType.type === "TSTypeReference") {
        if (aType.typeName.type === 'Identifier') {
            return aType.typeName.name || 'x';
        } else {
            throw new Error(aType.typeName.type);
        }
        //console.log('zz ' + aType.typeName.type);
  */  } else if (aType.type === 'TSAnyKeyword') {
        return 'any';
    } else if (aType.type === 'TSArrayType') {
        return typeDescription(aType.elementType) + '[]';

    } else if (aType.type === 'TSTypeLiteral') {
        return aType.members.map(member => member.type).join(' ');
    } else if (aType.type === 'TSNumberKeyword') {
        return 'number';
    } else if (aType.type === 'TSStringKeyword') {
        return 'string';
    } else if (aType.type === 'TSBooleanKeyword') {
        return 'boolean';
    } else if (aType.type === 'TSUnionType') {
        return 'union';
    } else if (aType.type === 'TSParenthesizedType') {
        return 'parenthesized';
    } else if (aType.type === 'TSFunctionType') {
        return 'function'
    } else {
        throw new Error(aType.type);
    }
}

