import { ArgumentParser } from 'argparse'
import {getBuilderName, builders as b, namedTypes as n} from 'ast-types';
import * as k from 'ast-types/gen/kinds';
import {print} from 'recast';
import fs from 'fs';
import * as ts from 'typescript';
import winston from 'winston';
import { ok } from 'assert';

const argParser = new ArgumentParser({});
argParser.addArgument(['-i', '--input-filename'], { required: false, help: 'json file to convert to typescript', defaultValue: 0 })
argParser.addArgument(['-o', '--output-filename'], { required: false, help: 'output file (default is stdout)', defaultValue: 1 })
const args = argParser.parseArgs();

const printer = ts.createPrinter({newLine: ts.NewLineKind.LineFeed})

const d = JSON.parse(fs.readFileSync(args.input_filename, {encoding: 'utf-8'}));

const preamble = [b.importDeclaration([
    b.importSpecifier(b.identifier('extend'),
        b.identifier('extend'))], b.literal('./src/translateLib'))]
preamble[0].comments = [b.commentBlock(' Preamble ')]

const body = [...preamble]

d.forEach((x: any) => {
    body.push(b[getBuilderName(x.type)].from(x))
});

const file = b.file(b.program(body));
file.comments = [b.commentBlock(' Generated by translate.ts ')]

fs.writeFileSync(args.output_filename, print(file).code + "\n", 'utf-8')

let program = ts.createProgram([args.output_filename], {
    target: ts.ScriptTarget.ES5,
    module: ts.ModuleKind.CommonJS
})
let checker = program.getTypeChecker();
for (const sourceFile of program.getSourceFiles()) {
    if (sourceFile.fileName === args.output_filename) {
        ts.forEachChild(sourceFile, visit());
        const resultFile = ts.createSourceFile("out2.ts", "", ts.ScriptTarget.Latest, false, ts.ScriptKind.TS)
        const result = printer.printNode(ts.EmitHint.Unspecified, sourceFile, resultFile)
        fs.writeFileSync('out2.ts', result, 'utf-8')
    }
}

function visit(collect?: any) {
    return (node: ts.Node) => {
        const printer = ts.createPrinter({newLine: ts.NewLineKind.LineFeed})
        const resultFile = ts.createSourceFile("temp.ts", "", ts.ScriptTarget.Latest, false, ts.ScriptKind.TS)
        if(ts.isMethodDeclaration(node)) {
            let symbol = checker.getSymbolAtLocation(node.name);
            if (symbol) {
                const node1 = symbol.valueDeclaration!;
		const sig = checker.getSignatureFromDeclaration(node)
                const typ = checker.getReturnTypeOfSignature(sig);
                //console.log(printer.printNode(ts.EmitHint.Unspecified, node, resultFile))
                node.type = checker.typeToTypeNode(typ)
                //console.log(printer.printNode(ts.EmitHint.Unspecified, node, resultFile))
                const t = checker.typeToString(
                    typ)
//                console.log(node);
	    }
        } else if (ts.isVariableDeclaration(node)) {
            let symbol = checker.getSymbolAtLocation(node.name);
            if (symbol) {
                const node1 = symbol.valueDeclaration!;
                const tt = checker.getTypeOfSymbolAtLocation(symbol, node1);
                console.log(printer.printNode(ts.EmitHint.Unspecified, node, resultFile))
                const new_node = ts.createVariableDeclaration(node.name, checker.typeToTypeNode(tt), node.initializer)
                node.type = checker.typeToTypeNode(tt)
                console.log(printer.printNode(ts.EmitHint.Unspecified, node, resultFile))
                //                console.log(printer.printNode(ts.EmitHint.Unspecified, new_node, resultFile))
                const t = checker.typeToString(
                    tt)
                console.log(node);
                /*                if('declarations' in node.parent) {
                        const index = node.parent.declarations.indexOf(node)
                        ok(index !== -1)
                        const decl = [...node.parent.declarations]
                        decl[index] = new_node
                        node.parent.declarations = decl
                    }
    		*/
                //return new_node;
            }
            ts.forEachChild(node, visit());
        } else {
            const x = ts.forEachChild(node, visit());
            if (x) {
                console.log(x);
            }
        }
    };
}


